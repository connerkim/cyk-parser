# -*- coding: utf-8 -*-
"""HW3 - Conner Kim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kUChCBZb3cicPRd648vbq5YlNL7MSh_v

# Conner Kim - HW3
## 1. Parsing
"""

!pip install anytree
from anytree import Node, RenderTree
from google.colab import drive
drive.mount('/content/drive')

"""### Part (a)"""

# returns lines of a file as an array of strings
def getLines(file):
    with open(file) as f:
        lines = f.read()
        lines = lines.split('\n')
    
        return lines

# returns only the rules in the form A -> b
def getUnitRules(lines):
    rules = []
    for line in lines:
        terms = line.split()
        if len(terms) == 2 and terms[1].islower():
            rules.append(line)
    
    return rules

# returns only the rules in the form A -> BC
def getThreeRules(lines):
    rules = []
    for line in lines:
        terms = line.split()
        if len(terms) == 3:
            rules.append(line)

    return rules

# returns all parse trees for the given sentence
def getTrees(sentence, rules):
    words = sentence.split()
    n = len(words)
    table = [[[] for x in range(n)] for y in range(n)]

    unit_rules = getUnitRules(rules)
    three_rules = getThreeRules(rules)

    # get tags for each of the sentence words
    for i in range(n):
        for unit_rule in unit_rules:
            terms = unit_rule.split()
            if terms[1] == words[i]:
                table[i][i].append(Node(terms[0]))

    # CYK algorithm
    l = 1
    while l <= n - 1:
        i = 0
        while i <= n - l - 1:
            j = i + l
            k = i
            while k <= j - 1:
                for three_rule in three_rules:
                    terms = three_rule.split()
                    index_of_b = -1
                    index_of_c = -1
                    for m in range(len(table[k][i])):
                        if table[k][i][m].name == terms[1]:
                            index_of_b = m
                    for m in range(len(table[j][k+1])):
                        if table[j][k+1][m].name == terms[2]:
                            index_of_c = m
                    if index_of_b != -1 and index_of_c != -1:
                        parent = Node(terms[0])
                        table[j][i].append(parent)
                        parent.children = [table[j][k+1][index_of_c], table[k][i][index_of_b]]

                k += 1
            i += 1
        l += 1

    # print all parses
    parents = table[n-1][0]
    #print(table)
    print("Number of Parses: {}".format(len(parents)))
    for parent in parents:  
        print(RenderTree(parent))

    return table, parents

"""### Part (b)"""

# returns rules in chomsky normal form
def chomsky(lines):
    var_num = 0
    i = 0
    while i <= len(lines):
        if (i == len(lines)):
            break
        terms = lines[i].split()
        num_terms = len(terms)

        # replace prod rules that have > 2 symbols on right side
        if num_terms == 4:
            new_rule_1 = ""
            new_rule_2 = ""
            new_rule_1 += terms[0] + " "
            new_rule_1 += terms[1] + " "
            if var_num == 0:
                new_rule_1 += 'X'
                new_rule_2 += 'X '
            if var_num == 1:
                new_rule_1 += 'Y'
                new_rule_2 += 'Y '
            if var_num == 2:
                new_rule_1 += 'Z'
                new_rule_2 += 'Z '
            new_rule_2 += terms[2] + " "
            new_rule_2 += terms[3]
            lines.append(new_rule_1)
            lines.append(new_rule_2)
            lines.remove(lines[i])
            i -= 1
            var_num += 1
    
        # replace prod rules w/ 1 var on right side
        if num_terms == 2 and not terms[1].islower():
            for line in lines:
                sub_terms = line.split()
                if terms[1] == sub_terms[0] and sub_terms[1].islower():
                    lines.append(terms[0] + " " + sub_terms[1])
            lines.remove(lines[i])
            i -= 1
        i += 1
        
    return lines

"""### Part (c)"""

# print parse treees for each sentence in 3-1.txt
rules = chomsky(getLines('/content/drive/My Drive/3-1b.txt'))
sentences = getLines('/content/drive/My Drive/3-1c.txt')
for sentence in sentences:
    getTrees(sentence, rules)

"""### Part (d)"""

# for those sentences who do not parse completely, return the longest sub-parse
def getLongestPartial(table):
    base = Node("")
    for nodes in table:
        maxNum = 0
        for node in nodes:
            for nodey in node:
                if nodey != None and len(nodey.name.split('/')) > maxNum:
                    maxNum = len(nodey.name)
                    base = nodey

    while base.parent != None:
        base = base.parent
    
    print(RenderTree(base))

for sentence in sentences:
    table, parents = getTrees(sentence, rules)
    if len(parents) == 0:
        getLongestPartial(table)

"""### Part (e)"""

# change rules such that the parser will not parse ungrammatical sentences
def changeRules(rules):
    i = 0

    rules.append("S PluralN PluralV")
    rules.append("S PluralNP PluralV")
    rules.append("PluralNP Det PluralN")
    rules.remove("VP V NP NP")
    rules.append("VP DoubleV NP NP")
    rules.remove("VP V NP PP")
    rules.append("VP PrepV NP PP")

    while i <= len(rules):
        if (i == len(rules)):
            break
        terms = rules[i].split()

        # replace prod rules that have > 2 symbols on right side
        if terms[1] == "cars" or terms[1] == "fly":
            rules[i] = "Plural" + terms[0] + " " + terms[1]

        if terms[1] == "gave":
            rules[i] = "Double" + terms[0] + " " + terms[1]

        if terms[1] == "put":
            rules[i] = "Prep" + terms[0] + " " + terms[1]

        i += 1
        
    #print(rules)
    return rules
            
rules = getLines('/content/drive/My Drive/3-1b.txt')
rules = changeRules(rules)
rules = chomsky(rules)
getTrees("the man put the baby", rules)

print('''Explanation:
I targeted the verbs in each sentence (fly, hit, and put)
and saw that they each took different types and numbers of tags in order to form
a verb phrase: 

fly follows a noun phrase where the noun is plural (cars instead
of car), so I changed the cars tag to a plural noun and the fly tag to a plural
one. I then added rules that constituted the forming of sentences made up of
sentences using plural noun phrases and plural verbs.

hit comes before two noun phrases, which is not a usage of hit that can form
a verb phrase; this instance is saved for verbs like "gave" (the man gave
the baby the car), so I deleted the rule "VP V NP NP", and made it more
specific to verbs that take double NPs by changing "gave" to a DoubleV(erb)
and changing the aformentioned rule to "VP DoubleV NP NP" instead, so that
the verb "hit" could not use this rule

finally, put preceded a noun phrase, but put forms verb phrases when it precedes
a NP and PP. I changed the put verb tag to a PrepV tag to be more specific,
then changed the rule that stated "VP V NP PP", as it applied to too many verbs.
The new rule, "VP PrepV NP PP", only applies to verbs like put that form VPs
when they precede NP and PPs.''')

